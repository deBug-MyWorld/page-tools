<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 3D 高度地形地球</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            pointer-events: none;
        }
        .hidden { opacity: 0; }
    </style>
</head>
<body>
    <div id="loading">正在加载高分辨率纹理...</div>
    <div id="info">
        左键旋转 | 右键平移 | 滚轮缩放<br>
        地形夸张比例已调高以突出结构
    </div>
    <div id="canvas-container"></div>

    <!-- 引入 Three.js 和 OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // 初始化场景、相机和渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 22); // 初始相机位置

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // 开启阴影映射
        renderer.shadowMap.enabled = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;
        controls.minDistance = 12; // 限制最近距离，防止穿模
        controls.maxDistance = 50;

        // 纹理加载管理器
        const manager = new THREE.LoadingManager();
        manager.onLoad = function () {
            const loadingScreen = document.getElementById('loading');
            loadingScreen.classList.add('hidden');
            // 开始动画循环
            animate();
        };

        const textureLoader = new THREE.TextureLoader(manager);

        // --- 材质纹理 URL (使用稳定的 GitHub Raw 源) ---
        // 地球颜色
        const colorMapUrl = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg';
        // 地球法线/高度 (用于地形突出)
        const displacementMapUrl = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg'; 
        // 镜面高光 (用于区分海洋和陆地反光)
        const specularMapUrl = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg';
        // 云层
        const cloudsMapUrl = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_1024.png';

        // --- 1. 创建地球 ---
        // 为了让地形突出，我们需要极高的段数 (256, 256) 以支持顶点位移
        const earthGeometry = new THREE.SphereGeometry(10, 256, 256);
        
        const earthMaterial = new THREE.MeshStandardMaterial({
            map: textureLoader.load(colorMapUrl),
            
            // 关键点：使用 Normal Map 作为 Displacement Map 的数据源（黑白高度信息）
            // 虽然这里叫 normal map，但在 three.js 示例中常被复用作为高度参考
            displacementMap: textureLoader.load(displacementMapUrl),
            displacementScale: 0.8, // 【核心设置】地形夸张程度，值越大山脉越高
            
            roughnessMap: textureLoader.load(specularMapUrl), // 海洋光滑，陆地粗糙
            roughness: 0.8,
            metalness: 0.1,
        });

        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.castShadow = true;
        earth.receiveShadow = true;
        scene.add(earth);

        // --- 2. 创建云层 ---
        const cloudGeometry = new THREE.SphereGeometry(10.15, 64, 64); // 稍微比地球大一点
        const cloudMaterial = new THREE.MeshPhongMaterial({
            map: textureLoader.load(cloudsMapUrl),
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
        scene.add(clouds);

        // --- 3. 创建大气光晕 (Fresnel 效果模拟) ---
        const atmosphereGeometry = new THREE.SphereGeometry(10.0, 64, 64);
        const atmosphereMaterial = new THREE.ShaderMaterial({
            vertexShader: `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vNormal;
                void main() {
                    float intensity = pow(0.65 - dot(vNormal, vec3(0, 0, 1.0)), 4.0);
                    gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
                }
            `,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            transparent: true
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        atmosphere.scale.set(1.15, 1.15, 1.15);
        scene.add(atmosphere);

        // --- 4. 星空背景 ---
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 2000;
        const starPositions = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) {
            starPositions[i] = (Math.random() - 0.5) * 600;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8});
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // --- 灯光设置 ---
        const ambientLight = new THREE.AmbientLight(0x333333); // 环境光
        scene.add(ambientLight);

        // 太阳光（平行光），从侧面照射以突出地形阴影
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(50, 20, 30);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // 辅助光，稍微照亮背面
        const spotLight = new THREE.SpotLight(0x3366ff, 0.5);
        spotLight.position.set(-50, 0, 20);
        scene.add(spotLight);

        // --- 响应窗口大小调整 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            // 自转
            earth.rotation.y += 0.001;
            clouds.rotation.y += 0.0014; // 云层比地球转得快一点
            stars.rotation.y -= 0.0002; // 背景缓慢反向旋转

            controls.update();
            renderer.render(scene, camera);
        }

        // 注意：如果纹理长时间未加载，可能是因为 GitHub Raw 访问受限。
        // 这种情况下，通常会自动回退到某种默认状态，或者只需刷新即可。
    </script>
</body>
</html>